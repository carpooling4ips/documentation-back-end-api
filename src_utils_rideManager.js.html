

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> src/utils/rideManager.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-src_main.html">src/main</a></li></ul></div><div class="category"><h2>Controllers</h2><h3>Modules</h3><ul><li><a href="module-AuthController.html">AuthController</a></li><li><a href="module-DebugNotificationController.html">DebugNotificationController</a></li><li><a href="module-UserController.html">UserController</a></li><li><a href="module-UserProfileController.html">UserProfileController</a></li><li><a href="module-UserRideGroupController.html">UserRideGroupController</a></li><li><a href="module-UserRideScheduleController.html">UserRideScheduleController</a></li><li><a href="module-UserSettingsController.html">UserSettingsController</a></li><li><a href="module-UserUserBlacklistController.html">UserUserBlacklistController</a></li><li><a href="module-UserVehicleController.html">UserVehicleController</a></li></ul><h3>Classes</h3><ul><li><a href="module-AuthController.html">AuthController</a></li><li><a href="module-DebugNotificationController.html">DebugNotificationController</a></li><li><a href="module-UserController.html">UserController</a></li><li><a href="module-UserProfileController.html">UserProfileController</a></li><li><a href="module-UserRideGroupController.html">UserRideGroupController</a></li><li><a href="module-UserRideScheduleController.html">UserRideScheduleController</a></li><li><a href="module-UserSettingsController.html">UserSettingsController</a></li><li><a href="module-UserUserBlacklistController.html">UserUserBlacklistController</a></li><li><a href="module-UserVehicleController.html">UserVehicleController</a></li></ul></div><div class="category"><h2>Models</h2><h3>Modules</h3><ul><li><a href="module-ChatMessageModel.html">ChatMessageModel</a></li><li><a href="module-ChatRoomModel.html">ChatRoomModel</a></li><li><a href="module-NewsModel.html">NewsModel</a></li><li><a href="module-NotificationModel.html">NotificationModel</a></li><li><a href="module-RideGroupModel.html">RideGroupModel</a></li><li><a href="module-RideHistoryModel.html">RideHistoryModel</a></li><li><a href="module-RideRouteModel.html">RideRouteModel</a></li><li><a href="module-RideScheduleModel.html">RideScheduleModel</a></li><li><a href="module-UserModel.html">UserModel</a></li><li><a href="module-UserNotificationModel.html">UserNotificationModel</a></li><li><a href="module-VehicleModel.html">VehicleModel</a></li></ul></div><div class="category"><h2>Models.Schemas</h2><h3>Modules</h3><ul><li><a href="module-BoundarySchema.html">BoundarySchema</a></li><li><a href="module-FileSchema.html">FileSchema</a></li><li><a href="module-LocationSchema.html">LocationSchema</a></li><li><a href="module-PointSchema.html">PointSchema</a></li></ul></div><div class="category"><h2>Routes</h2><h3>Modules</h3><ul><li><a href="module-AuthRoute.html">AuthRoute</a></li><li><a href="module-DebugNotificationRoute.html">DebugNotificationRoute</a></li><li><a href="module-DebugRoute.html">DebugRoute</a></li><li><a href="module-UserProfileRoute.html">UserProfileRoute</a></li><li><a href="module-UserRideGroupRoute.html">UserRideGroupRoute</a></li><li><a href="module-UserRideScheduleRoute.html">UserRideScheduleRoute</a></li><li><a href="module-UserRoute.html">UserRoute</a></li><li><a href="module-UserSettingRoute.html">UserSettingRoute</a></li><li><a href="module-UserUserBlacklistRoute.html">UserUserBlacklistRoute</a></li><li><a href="module-UserVehicleRoute.html">UserVehicleRoute</a></li></ul></div><div class="category"><h2>Utils</h2><h3>Modules</h3><ul><li><a href="module-ApiError.html">ApiError</a></li><li><a href="module-NotificationManager.html">NotificationManager</a></li><li><a href="module-RideManager.html">RideManager</a></li><li><a href="module-Validator.html">Validator</a></li></ul><h3>Classes</h3><ul><li><a href="module-ApiError.html">ApiError</a></li><li><a href="module-NotificationManager.html">NotificationManager</a></li><li><a href="module-RideManager.html">RideManager</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>src/utils/rideManager.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module RideManager
 * @category Utils
 */

'use strict'

/*
 * ==================================================
 * | Imports                                        |
 * ==================================================
 */
import luxon from 'luxon'
import googleMapsServicesJs from '@googlemaps/google-maps-services-js'
import debug from 'debug'
import HttpStatus from 'http-status-codes'

import ApiError from './apiError.js'
import NotificationManager from './notificationManager.js'

// Models
import { RideGroupModel, RideScheduleModel, RideRouteModel } from '../models/index.js'

/*
 * ==================================================
 * | Constants                                      |
 * ==================================================
 */
const { ReasonPhrases, StatusCodes } = HttpStatus
const { DateTime, Duration, Interval } = luxon
const { Client: MapsClient, TravelMode, TravelRestriction, Language: MapsLanguage } = googleMapsServicesJs

// The string in lowercase to search the existence of tolls from html instructions of Google Directions API
const GOOGLE_DIRECTIONS_API_TOLL_CHECK_STRING = 'portagem'

// Debug package
const debugApp = debug('carpooling4ips')
const debugRideManager = debugApp.extend('rideManager')

/*
 * ==================================================
 * | Exports                                        |
 * ==================================================
 */

/**
 * Class representing the ride manager.
 *
 * @category Utils
 */
export default class {
  /**
   * ...
   *
   * @param session
   */
  constructor (session = null) {
    this._session = session
  }

  /**
   * Create a new ride group with specified data.
   *
   * @param alias
   * @param driverId
   * @param vehicleId
   * @param passengers
   * @param meetingPoint
   * @param toDestination
   * @param avoidTolls
   * @param recurrent
   * @param weekDays
   * @param departureTime
   */
  async createGroup (
    alias,
    driverId,
    vehicleId,
    passengers,
    meetingPoint,
    toDestination,
    avoidTolls,
    recurrent = false,
    weekDays = {},
    departureTime = undefined
  ) {
    // Create ride group document
    const rideGroupDoc = new RideGroupModel({
      alias: alias,
      driverId: driverId,
      vehicleId: vehicleId,
      passengers: {},
      meetingPoint: {
        type: 'Point',
        coordinates: [
          meetingPoint.longitude,
          meetingPoint.latitude
        ]
      },
      toDestination: toDestination,
      avoidTolls: avoidTolls
    })
    if (passengers) {
      for (const passengerId of passengers) {
        rideGroupDoc.passengers.set(passengerId, {
          userId: passengerId
        })
      }
    }
    if (recurrent === true) {
      rideGroupDoc.recurrent = {
        weekDays: {
          monday: weekDays.monday,
          tuesday: weekDays.tuesday,
          wednesday: weekDays.wednesday,
          thursday: weekDays.thursday,
          friday: weekDays.friday,
          saturday: weekDays.saturday,
          sunday: weekDays.sunday
        },
        departureTime: departureTime
      }
    }

    return await rideGroupDoc.save({ session: this._session })
  }

  /**
   * Request to the Google Directions API to calculate the route of the given origin and destination
   *
   * @param origin
   * @param destination
   * @param avoidTolls
   */
  async _requestRouteToGoogleDirectionsApi (origin, destination, avoidTolls) {
    // Prepare avoid options
    const avoid = []
    if (avoidTolls === true) avoid.push(TravelRestriction.tolls)

    // Request the routes to Google Directions API
    const mapsClient = new MapsClient({})
    const directionsResult = await mapsClient.directions({
      params: {
        origin: origin,
        destination: destination,
        language: MapsLanguage.pt_PT,
        alternatives: true,
        travelMode: TravelMode.driving,
        avoid: avoid,
        key: process.env.GOOGLE_MAPS_API_KEY
      }
    })

    // Check if the calculated routes are valid
    if (directionsResult.data.status !== 'OK' || !Array.isArray(directionsResult.data.routes) || directionsResult.data.routes.length === 0) {
      throw new ApiError('No routes found for the specified meeting point. Please, select a different location.', StatusCodes.UNPROCESSABLE_ENTITY) // TODO Use i18n
    }

    // Add retrieved routes to the database
    const routeDocs = []
    const bestRoute = {
      index: -1,
      _id: null,
      distance: null,
      duration: null
    }
    for (const [i, route] of directionsResult.data.routes.entries()) {
      const leg = route.legs[0]

      // Check if route has tolls
      const hasTolls = leg.steps.findIndex((step) => step.html_instructions.toLowerCase().includes(GOOGLE_DIRECTIONS_API_TOLL_CHECK_STRING)) !== -1

      // Create ride group route document
      const routeDoc = new RideRouteModel({
        summary: route.summary,
        duration: leg.duration.value,
        distance: leg.distance.value,
        startLocation: {
          address: leg.start_address,
          point: {
            type: 'Point',
            coordinates: [leg.start_location.lng, leg.start_location.lat]
          }
        },
        endLocation: {
          address: leg.end_address,
          point: {
            type: 'Point',
            coordinates: [leg.end_location.lng, leg.end_location.lat]
          }
        },
        polyline: route.overview_polyline.points,
        boundary: {
          southwest: {
            type: 'Point',
            coordinates: [route.bounds.southwest.lng, route.bounds.southwest.lat]
          },
          northeast: {
            type: 'Point',
            coordinates: [route.bounds.northeast.lng, route.bounds.northeast.lat]
          }
        },
        hasTolls: hasTolls
      })
      routeDocs.push(routeDoc)

      // Calc the best route. The best route is considered to be the shorter in distance and, if tied, the duration is also considered.
      if (bestRoute.index === -1 ||
          leg.distance.value &lt; bestRoute.distance ||
          (leg.distance.value === bestRoute.distance &amp;&amp; leg.duration.value &lt; bestRoute.duration)) {
        bestRoute.index = i
        bestRoute._id = routeDoc._id
        bestRoute.distance = routeDoc.distance
        bestRoute.duration = routeDoc.duration
      }
    }

    // Insert the calculated routes to the database
    await RideRouteModel.create(routeDocs, {
      session: this._session
    })

    // Return the best and alternative routes
    return {
      bestRoute: bestRoute,
      routes: routeDocs
    }
  }

  /**
   * Create a new ride group to the specified user.
   *
   * @param groupId
   * @param meetingPoint
   * @param toDestination
   * @param avoidTolls
   */
  async calcRoutes (groupId, meetingPoint, toDestination, avoidTolls) {
    try {
      // Prepare origin and destination coordinates
      const fixedPointCoordinates = process.env.RIDE_GROUP_FIXED_POINT.split(',')
      let origin, destination
      if (toDestination) {
        origin = {
          latitude: meetingPoint.latitude,
          longitude: meetingPoint.longitude
        }
        destination = {
          latitude: Number(fixedPointCoordinates[0]),
          longitude: Number(fixedPointCoordinates[1])
        }
      } else {
        origin = {
          latitude: Number(fixedPointCoordinates[0]),
          longitude: Number(fixedPointCoordinates[1])
        }
        destination = {
          latitude: meetingPoint.latitude,
          longitude: meetingPoint.longitude
        }
      }

      // Check for existing routes and if found reuse it in order to avoid unnecessary requests to the Google Directions API
      const circleRadiusRadians = (process.env.RIDE_ROUTE_MATCH_MAX_DISTANCE_METERS / 1000) / 6378.1
      const aggregateCondition = {
        $match: {
          'startLocation.point': {
            $geoWithin: { $centerSphere: [[origin.longitude, origin.latitude], circleRadiusRadians] }
          },
          'endLocation.point': {
            $geoWithin: { $centerSphere: [[destination.longitude, destination.latitude], circleRadiusRadians] }
          }
        }
      }
      // TODO Improvement: The system is not able to detect if a route with tolls for the specified origin and destination has been calculated before, so in the case of the user request an origin and destination with tolls allowed but there are already routes calculated without tools the system is going to pick a route without tools instead of requesting new routes to the Google Directions API.
      if (avoidTolls === true) {
        aggregateCondition.$match.hasTolls = false
      }
      const foundRoutes = await RideRouteModel.aggregate([
        aggregateCondition
      ])
        .sort({
          distance: 1,
          duration: 1
        })
        .exec()

      let bestRoute
      let alternativeRoutes
      if (foundRoutes &amp;&amp; foundRoutes.length > 0) {
        debugRideManager('Requested routes found on the database, reusing!')

        bestRoute = foundRoutes[0]
        alternativeRoutes = foundRoutes.slice(1)
      } else {
        debugRideManager('Requested routes not found on the database! Requesting route data from the Google Directions API.')

        const calculatedRoutes = await this._requestRouteToGoogleDirectionsApi(origin, destination, avoidTolls)
        bestRoute = calculatedRoutes.bestRoute
        alternativeRoutes = calculatedRoutes.routes.filter((value, i) => {
          if (bestRoute.index === i) return false
          return true
        })
      }

      // Add the route ids to the ride group
      // NOTE: This query does not trigger mongoose schema validators
      await RideGroupModel.updateOne({
        _id: groupId
      }, {
        route: bestRoute._id,
        alternativeRoutes: alternativeRoutes.map(value => value._id)
      }, {
        session: this._session
      }).exec()
    } catch (err) {
      debugRideManager(err)
      throw new ApiError('The ride group routes could not be calculated. Please, try again later.', StatusCodes.INTERNAL_SERVER_ERROR) // TODO Use i18n
    }
  }

  /**
   * Create a new ride group to the specified user.
   *
   * @param groupId
   * @param dates
   */
  async addSchedules (groupId, dates) {
    const schedulesPromises = []
    for (const date of dates) {
      schedulesPromises.push(this._addSchedule(groupId, date))
    }

    return await Promise.all(schedulesPromises)
  }

  /**
   * @param rideGroupId
   * @param realizationDate
   */
  async _addSchedule (rideGroupId, realizationDate) {
    // Insert the schedule to the ride group, or update if already exists
    let rideScheduleDoc = await RideScheduleModel.findOne({
      rideGroupId: rideGroupId,
      realizationDate: realizationDate,
      isDisabled: false
    }).session(this._session)
    if (!rideScheduleDoc) {
      rideScheduleDoc = new RideScheduleModel()
    }
    rideScheduleDoc.rideGroupId = rideGroupId
    rideScheduleDoc.realizationDate = realizationDate
    await rideScheduleDoc.save()
  }

  /**
   * Disable the specified ride group.
   *
   * @param groupId
   * @param driverId
   */
  async disableGroup (groupId, driverId) {
    // Disable the ride group
    // NOTE: This query does not trigger mongoose schema validators
    const groupUpdateResult = await RideGroupModel.updateOne({
      _id: groupId,
      driverId: driverId,
      isDisabled: false
    }, {
      isDisabled: true
    }, {
      session: this._session
    }).exec()
    if (groupUpdateResult.n === 0) {
      throw new ApiError(ReasonPhrases.NOT_FOUND, StatusCodes.NOT_FOUND)
    }

    // Disable ride group's schedules
    // NOTE: This query does not trigger mongoose schema validators
    await RideScheduleModel.updateMany({
      rideGroupId: groupId,
      realizationDate: { $gte: new Date() },
      status: RideScheduleModel.schema.statics.Status.Scheduled,
      isDisabled: false
    }, {
      isDisabled: true
    }, {
      session: this._session
    }).exec()
  }

  /**
   * Renew the schedules of the specified ride group.
   *
   * @param groupId
   * @param fromExpirationDate
   */
  async renewGroup (groupId, fromExpirationDate = false) {
    // Retrieve ride group document by its id and ensures it is a recurrent group
    const rideGroupDoc = await RideGroupModel.findOne({
      _id: groupId,
      'recurrent.weekDays': { $exists: true },
      'recurrent.departureTime': { $exists: true }
    })
      .lean()
      .session(this._session)
      .exec()
    if (!rideGroupDoc) return false

    // Get week days
    const weekDays = []
    if (rideGroupDoc.recurrent.weekDays.monday === true) weekDays.push(1)
    if (rideGroupDoc.recurrent.weekDays.tuesday === true) weekDays.push(2)
    if (rideGroupDoc.recurrent.weekDays.wednesday === true) weekDays.push(3)
    if (rideGroupDoc.recurrent.weekDays.thursday === true) weekDays.push(4)
    if (rideGroupDoc.recurrent.weekDays.friday === true) weekDays.push(5)
    if (rideGroupDoc.recurrent.weekDays.saturday === true) weekDays.push(6)
    if (rideGroupDoc.recurrent.weekDays.sunday === true) weekDays.push(7)

    // Check if start date should be calculated from expiration date
    const currentDate = DateTime.utc()
    let workingDate
    if (fromExpirationDate) {
      const expirationNotifyDuration = Duration.fromISO(process.env.RIDE_GROUP_RECURRENT_EXPIRATION_NOTIFY)
      const expirationDate = DateTime.fromJSDate(rideGroupDoc.recurrent.expiration).toUTC()

      if (currentDate &lt; expirationDate.minus(expirationNotifyDuration)) {
        throw new ApiError('A ride group can only be renewed ' + expirationNotifyDuration.as('days') + ' days before its expiration.', StatusCodes.UNPROCESSABLE_ENTITY) // TODO Use i18n
      }

      workingDate = expirationDate.startOf('minute')
    } else {
      workingDate = currentDate.startOf('minute')
    }

    // Handle dates interval
    const [departureHours, departureMinutes] = rideGroupDoc.recurrent.departureTime.split(':')
    const durationToEnd = Duration.fromISO(process.env.RIDE_GROUP_RECURRENT_EXPIRATION)

    let startDate = workingDate.set({ hours: departureHours, minutes: departureMinutes })
    const endDate = startDate.plus(durationToEnd)
    if (workingDate > startDate) {
      startDate = startDate.plus({ days: 1 })
    }

    const intervalDates = Interval.fromDateTimes(startDate, endDate).splitBy({ days: 1 }).map(interval => interval.start)

    // Prepare new schedule dates
    const scheduleDates = []
    for (const date of intervalDates) {
      if (weekDays.includes(date.weekday)) {
        scheduleDates.push(date.toJSDate())
      }
    }

    // Add new schedule dates
    this.addSchedules(groupId, scheduleDates)

    // Update ride group expiration date
    // NOTE: This query does not trigger mongoose schema validators
    await RideGroupModel.updateOne({
      _id: groupId
    }, {
      'recurrent.expiration': endDate.toJSDate(),
      'recurrent.notifiedExpiration': false
    },
    {
      session: this._session
    })

    return true
  }

  /**
   * Check expiring ride groups and notify drivers for renewal.
   */
  static async checkExpirations () {
    const expirationNotifyDuration = Duration.fromISO(process.env.RIDE_GROUP_RECURRENT_EXPIRATION_NOTIFY)
    const expirationCheckDate = DateTime.utc().plus(expirationNotifyDuration)

    const rideGroupDocs = await RideGroupModel.find({
      'recurrent.expiration': { $lte: expirationCheckDate },
      'recurrent.notifiedExpiration': { $ne: true },
      isDisabled: false
    })

    const expirationsPromises = []
    for (const doc of rideGroupDocs) {
      expirationsPromises.push(async function (doc) {
        // Notify the driver for the ride group renewal
        // TODO Add a custom button for Renew
        NotificationManager.send(doc.driverId, 'DRIVER_RIDE_GROUP_EXPIRATION', {
          RIDE_GROUP_ALIAS: doc.alias
        })

        // Update the ride group notified expiration field
        await RideGroupModel.updateOne({
          _id: doc._id
        }, {
          'recurrent.notifiedExpiration': true
        })
      }(doc))
    }
    await Promise.all(expirationsPromises)
  }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
